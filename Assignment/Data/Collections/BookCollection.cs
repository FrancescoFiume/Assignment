using System.Reflection;
using Assignment.Data.Interfaces;
using Assignment.Data.Models;

namespace Assignment.Data.Collections;
/// <summary>
/// Books Collection is a class that takes care of regrouping all the Books in the db and offers easy access to CRUD
/// operations.
/// </summary>
public class BookCollection :IObjectCollection<Books>
{
    //DI
    private readonly IServiceProvider _serviceProvider;
    //Private cache
    private List<Books> _cache{get;set;}
    //Public cache
    /// <summary>
    /// The public chache doesn't have a setter for security reasons.
    /// It always reads either from the _cache or the Db
    /// </summary>
    public List<Books> Cache {
        
            get
            {
                using var scope = _serviceProvider.CreateScope();
                
                var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();

                if (!IsCacheUsed)
                {
                    _cache = context.Books.ToList();
                    IsCacheUsed = true;
                }
                
                return _cache;
            } }
    
    /// <summary>
    /// The reasoning behind isChacheUsed it to have some sort of protection when the project is freshly started.<br />
    /// If I had cache.Count() to check if the cache was empty then if you add an item to the
    /// collection before having the cache to get the data from the db then you would be stuck with a cache of a lenght 1 which
    /// would never update its content.
    /// </summary>
    public bool IsCacheUsed { get; set; }
    
    /// <summary>
    /// Simple Contrusctor
    /// </summary>
    /// <param name="serviceProvider">
    ///Dependency Injected service provided is needed for context operations
    /// </param>
    public BookCollection(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
        _cache = new List<Books>();
        IsCacheUsed = false;
    }
    /// <summary>
    /// GetById Takes an int and gives out the Item associated in the cache. or gives out an error.
    /// When first doesn't find anything it will throw an exception that will run to the controller and there
    /// it will be catched and managed with a not found response to the endpoint
    /// </summary>
    /// <param name="id">id of the element you want to find</param>
    /// <returns>If the id is in the db it returns the comeple object of the collection</returns>
    public Books GetById(int id)
    {
        return Cache.First(book => book.Id == id);
    }

    /// <summary>
    /// Add takes a Book class, disregards the Id and the Availability completely
    /// then it creates a new entry in the db and 
    /// </summary>
    /// <param name="book"> Books that needs to be added</param>
    /// <returns>gives back the item created with id and registration date</returns>
    public Books Add(Books book)
    {
        var newBook = new Books()
        {
            //No Id, it gets generated by postgre serial
            Title = book.Title,
            Author = book.Author,
            ISBN = book.ISBN,
            //No Availability for the same reason
        };
        using var scope = _serviceProvider.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
        context.Add(newBook);
        context.SaveChanges();
        if (IsCacheUsed)
        {
            _cache.Add(newBook);
        }
        return newBook;
        
    }
    /// <summary>
    ///Takes in a Book and takes care of the changes relative to author name and isbn.
    /// </summary>
    /// <param name="book"></param>
    public void Update(Books book)
    {
        using var scope = _serviceProvider.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();

        //can safely skip null checks, this parameter already passed the GetById check
        
        var bookToUpdateDb = context.Books.First(c => c.Id == book.Id);
        Type userType = book.GetType();
        PropertyInfo[] properties = userType.GetProperties();
        foreach (var property in properties)
        {
            if (property.PropertyType == typeof(string) && property.GetValue(book) as string != "")
            {
               
                var toUpdateProperty = typeof(Books).GetProperty(property.Name);
                toUpdateProperty!.SetValue(bookToUpdateDb, property.GetValue(book));
            }
            
        }
        context.SaveChanges();
        if (IsCacheUsed)
        {
            int index =_cache.FindIndex(b => b.Id == book.Id);
            _cache[index] = bookToUpdateDb;
        }
    }

    /// <summary>
    /// Let's think of this as a toggle, when you call this function you toggle the Availability.<br/>
    /// if the book is available it changes to unavailable, and vice versa.
    /// </summary>
    /// <param name="id">just needs the id of the book</param>
    public void ToggleAvailability(int id)
    {
        using var scope = _serviceProvider.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
        var toUpdate = context.Books.First(c => c.Id == id);
        if (toUpdate.Status == Books.Availability.Available)
        {
            toUpdate.Status = Books.Availability.Unavailable;
        }
        else
        {
            toUpdate.Status = Books.Availability.Available;
        }
        context.SaveChanges();
        if (IsCacheUsed)
        {
            int index =_cache.FindIndex(book => book.Id == id);
            _cache[index] = toUpdate;
        }
    }

    /// <summary>
    /// Deletes an entry in both cache (if used) and bd from the id
    /// </summary>
    /// <param name="id"></param>
    public void Delete(int id)
    {
        using var scope = _serviceProvider.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
        var toDelete = context.Books.First(book => book.Id == id);

        if (IsCacheUsed)
        {
            int index =_cache.FindIndex(book => book.Id == id);

            _cache.RemoveAt(index);
        }
        context.Books.Remove(toDelete);
        context.SaveChanges();
    }

    /// <summary>
    /// When the class is used as an Enumerable then it returns the cache's iterator
    /// </summary>
    /// <returns>
    ///If the cache has already been used, it returns _cache enumerator which is full, if it hasn't been used then it calls
    /// Cache so that the getter kicks in and reads the data from the db
    /// </returns>
    public IEnumerator<Books> GetEnumerator()
    {
        if (IsCacheUsed)
        {
            return _cache.GetEnumerator();
        }
        return Cache.GetEnumerator();
    }
}